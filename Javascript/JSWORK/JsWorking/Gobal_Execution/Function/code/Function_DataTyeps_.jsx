Feature,Stack (Values),Heap (Objects/Arrays/Functions)
Data Type,"Primitives (e.g., 10, true)","Reference Types (e.g., {}, [], function)"
Size,Fixed (Small),Variable (Large)
Allocation,Static (at compile/run time),Dynamic (during execution)
Access,Very Fast,Slower (requires following a pointer)
Analogy,A pocket (put small change here),A warehouse (store large furniture here)1


ï¸âƒ£ Two kinds of data in JavaScript

JavaScript splits data into two categories:

ğŸ”¹ Primitive (value types)
number, string, boolean, null, undefined, symbol, bigint

ğŸ”¹ Non-primitive (reference types)
object, array, function, date, map, set

2ï¸âƒ£ Why primitives are NOT stored in heap
Example
let x = 10
let y = x


Memory:

STACK
-------
x = 10
y = 10


Why stack is perfect for primitives?

âœ” Fixed size
âœ” Known at compile/runtime
âœ” Fast allocation
âœ” Easy to delete (LIFO)

Primitives are small, immutable, fixed-size values.

So:

Stack is fast

No GC needed

When function ends â†’ value disappears



3ï¸âƒ£ Why objects/arrays/functions ARE stored in heap
Example
let obj = { a: 1 }


Memory:

STACK
-------
obj â†’ 0xF123

HEAP
-------
0xF123 â†’ { a: 1 }

WHY heap?
ğŸ”¥ Reason 1: Dynamic size

Objects can:

obj.b = 2
obj.c = 3
delete obj.a


ğŸ‘‰ Size changes at runtime
âŒ Stack cannot resize memory
âœ… Heap can

ğŸ”¥ Reason 2: Shared references
let a = { x: 1 }
let b = a


Both point to same object

a â”€â”
   â”œâ”€â”€â–º 0xF123 â†’ { x: 1 }
b â”€â”˜


Stack copying would duplicate data âŒ
Heap reference avoids duplication âœ…

ğŸ”¥ Reason 3: Lifetime is unpredictable
function test() {
  return { x: 10 }
}


Object survives after function returns

âŒ Stack would be destroyed
âœ… Heap survives via reference

ğŸ”¥ Reason 4: Functions are executable objects
function add(a, b) {
  return a + b
}


A function stores:

Code

Scope

Metadata

ğŸ‘‰ Too large & complex for stack

4ï¸âƒ£ Why NOT store objects by value? (VERY IMPORTANT)

Imagine this:

let a = { x: 1 }
let b = a
b.x = 100


If stored by value:

a = { x: 1 }
b = { x: 1 }  // copy


Then:

b.x = 100


Would NOT affect a â€” but in JS it DOES.

So:

JS must use references to preserve object identity.

5ï¸âƒ£ Why strings are â€œspecialâ€
let s1 = "hello"
let s2 = s1


Strings are:

Primitive

Immutable

Engine may:

Store in stack

Or intern them in heap

You canâ€™t mutate them anyway

So behavior stays consistent.

6ï¸âƒ£ GC perspective (VERY IMPORTANT)

Heap objects:

Can live long

Can be shared

Need cleanup
â†’ Garbage Collector manages heap

Stack:

Auto cleanup

No GC

Very fast

7ï¸âƒ£ Interview-grade answer (ğŸ”¥)

â€œPrimitive values are stored directly because they are small, immutable, and fixed-size.
Objects, arrays, and functions are stored in heap because their size is dynamic, they can be shared across references, and their lifetime is unpredictable. Therefore, JavaScript uses references instead of value copying.â€

8ï¸âƒ£ One-line killer answer

Stack stores values; heap stores objects because objects are dynamic, shared, and long-lived.

9ï¸âƒ£ Visual memory rule (remember forever)
VALUE â†’ STACK
OBJECT â†’ HEAP
NAME â†’ REFERENCE
