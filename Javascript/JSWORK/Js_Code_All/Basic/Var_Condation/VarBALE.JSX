// 1ï¸âƒ£ var, let, const
var x = 1; let y = 2; const z = 3;
x = 10; y = 20; // ok
// z = 30; âŒ Error

console.log(x, y, z); // 10 20 3


let str = "Hello";
str[0] = "J";  // âŒ No effect
console.log(str.includes('J')); // "Hello"




Q ::Primitives are immutable, meaning their values cannot be changed 
once created (though you can reassign variables that hold them).


| Type          | Example                              | Description                                                   |
| ------------- | ------------------------------------ | ------------------------------------------------------------- |
| **string**    | `'hello'`, `"abc"`, `` `template` `` | Represents text                                               |
| **number**    | `42`, `3.14`, `-7`                   | Represents integers and floating numbers                      |
| **boolean**   | `true`, `false`                      | Represents logical true/false                                 |
| **undefined** | `let x; // x is undefined`           | A variable declared but not assigned any value                |
| **null**      | `let y = null;`                      | Represents an intentional empty value                         |
| **symbol**    | `let s = Symbol('id');`              | Unique and immutable identifier (added in ES6)                |
| **bigint**    | `123n`, `9007199254740991n`          | Used for very large integers beyond `Number.MAX_SAFE_INTEGER` |



// Immutable â†’ You cannot change a primitive value.

let str = "Hello";
str[0] = "J";  // âŒ No effect
console.log(str); // "Hello"


ğŸ¯ Summary for Interviews

| Concept            | Key Point                                                 |
| ------------------ | --------------------------------------------------------- |
| **Primitives**     | Immutable, compared by value                              |
| **Objects/Arrays** | Mutable, compared by reference                            |
| **`==` vs `===`**  | `==` allows coercion, `===` checks type too               |
| **`var`**          | Function-scoped, hoisted as `undefined`                   |
| **`let`**          | Block-scoped, hoisted but in TDZ                          |
| **`const`**        | Block-scoped, must be initialized and canâ€™t be reassigned |




ğŸ§® Part 1: Type Coercion and Equality
ğŸ§© console.log([] + [[]] + !![])

Letâ€™s evaluate this step by step:

Step 1: [] + [[]]

In JavaScript, when you use + with arrays or objects, theyâ€™re converted to strings.

[].toString() â†’ ''

[[]].toString() â†’ ''

So:

[] + [[]] â†’ '' + '' â†’ ''

Step 2: !![]

[] is a truthy value.
!![] â†’ true

Step 3: Combine all:
'' + true â†’ 'true'


âœ… Output:

true

ğŸ§© console.log('' + '' + true)

Both '' (empty strings) are concatenated with true:

'' + '' + true â†’ '' + 'true' â†’ 'true'


âœ… Output:

true

ğŸ§© console.log({} == [])

== checks after type coercion.
Objects are only equal to themselves (same reference).
But {} and [] are different object types.

âœ… Output:

false

ğŸ§© console.log({} === [])

=== checks strict equality, no type conversion.
Since {} and [] are different references (and types), itâ€™s clearly false.

âœ… Output:

false

ğŸ§© console.log('12' == 12)

== allows type coercion.
'12' is converted to a number â†’ 12 == 12.

âœ… Output:

true

ğŸ§© console.log(12 === '12')

=== checks both value and type.

Left: number

Right: string
â†’ Not same type

âœ… Output:

false




ğŸ§© console.log(12 === '12')
=== checks both value and type.

Left: number

Right: string
â†’ Not same type

âœ… Output:

arduino
Copy code
false
âš™ï¸ Part 2: var, let, and const



| Feature        | `var`                                  | `let`                                   | `const`                                 |
| -------------- | -------------------------------------- | --------------------------------------- | --------------------------------------- |
| **Scope**      | Function-scoped                        | Block-scoped                            | Block-scoped                            |
| **Re-declare** | âœ… Allowed                              | âŒ Not allowed                           | âŒ Not allowed                           |
| **Re-assign**  | âœ… Allowed                              | âœ… Allowed                               | âŒ Not allowed                           |
| **Hoisting**   | âœ… Hoisted (initialized as `undefined`) | âœ… Hoisted (but in *Temporal Dead Zone*) | âœ… Hoisted (but in *Temporal Dead Zone*) |



ğŸ§© Example 1 â€” Hoisting

console.log(x);
var x = 10;


ğŸ§  Explanation:

During the creation phase, var x is hoisted and initialized to undefined.

So JS reads it as:

var x;
console.log(x); // undefined
x = 10;


âœ… Output:

undefined

ğŸ§© Example 2 â€” Hoisting with let
// console.log(b);
let b = 10;


ğŸ§  Explanation:

let is hoisted but not initialized.

Itâ€™s in the Temporal Dead Zone (TDZ) until the declaration line is executed.

Accessing it before declaration throws a ReferenceError.

âœ… Output (if uncommented):

ReferenceError: Cannot access 'b' before initialization

ğŸ§© Example 3 â€” Re-assignment
let b = 10;
b = 'jugal sharma b';
console.log(b);


âœ… Allowed â€” let allows reassignment.

âœ… Output:

jugal sharma b

ğŸ§© Example 4 â€” const (constant)
const c = 12;
c = 'jugal';
console.log(c);


ğŸ§  Explanation:

const cannot be reassigned once set.

Attempting to reassign throws a TypeError.

âœ… Output:

TypeError: Assignment to constant variable.




ğŸ§© 5ï¸âƒ£ Interview Summary Table


| Feature                      | Pass by Value      | Pass by Reference     |
| ---------------------------- | ------------------ | --------------------- |
| **Data Type**                | Primitive types    | Non-primitive types   |
| **Memory Stored As**         | Actual value       | Reference (address)   |
| **Copy Behavior**            | Creates a new copy | Points to same memory |
| **Changes Affect Original?** | âŒ No               | âœ… Yes                 |
| **Example**                  | `let x = 5`        | `let obj = { a: 1 }`  |



ğŸ§© 1ï¸âƒ£ What does â€œPass by Valueâ€ mean?

When a variable is passed by value, a copy of the value is created.
Changing the copy does not affect the original variable.

âœ… Example â€” Pass by Value (Primitives)
let a = 10;
let b = a;   // Copy of 'a' is stored in 'b'

b = 20;

console.log(a); // 10 â†’ Original not affected
console.log(b); // 20


ğŸ§  Why?
Because number, string, boolean, undefined, null, symbol, and bigint are primitive â†’ stored directly in memory by value.

ğŸ“¦ Each variable gets its own box (memory space).

ğŸ§© 2ï¸âƒ£ What does â€œPass by Referenceâ€ mean?

When a variable is passed by reference, it stores a reference (memory address) to the actual object.
If you modify the object via one variable, it affects all variables pointing to it.

âœ… Example â€” Pass by Reference (Objects / Arrays)
let user1 = { name: "Jugal" };
let user2 = user1;  // user2 stores reference of user1

user2.name = "Sharma";

console.log(user1.name); // "Sharma" â† changed!
console.log(user2.name); // "Sharma"


ğŸ§  Why?
Because objects, arrays, and functions are non-primitive â†’ stored by 
reference (a pointer to a memory address).

ğŸ“ Both user1 and user2 point to the same memory location.

âš™ï¸ 3ï¸âƒ£ Visual Memory Representation



| Type           | Variable | Memory Value | Actual Value          |
| -------------- | -------- | ------------ | --------------------- |
| Primitive      | a        | `10`         | stored directly       |
| Primitive copy | b        | `10`         | independent copy      |
| Object         | user1    | `0x01`       | â†’ { name: "Jugal" }   |
| Reference      | user2    | `0x01`       | points to same object |






ğŸ§© 4ï¸âƒ£ How to Create a Copy (Not Reference)

Sometimes you want a real copy of an object or array (not a reference).

ğŸ§  Shallow Copy (1-level only)
let obj1 = { name: "Jugal", age: 25 };
let obj2 = { ...obj1 }; // Spread operator

obj2.name = "Sharma";

console.log(obj1.name); // "Jugal" âœ… not changed

ğŸ§  Deep Copy (Nested objects)
let deep1 = { user: { name: "Jugal" } };
let deep2 = structuredClone(deep1); // or JSON methods

deep2.user.name = "Sharma";

console.log(deep1.user.name); // "Jugal" âœ… not changed


| Feature                      | Pass by Value      | Pass by Reference     |
| ---------------------------- | ------------------ | --------------------- |
| **Data Type**                | Primitive types    | Non-primitive types   |
| **Memory Stored As**         | Actual value       | Reference (address)   |
| **Copy Behavior**            | Creates a new copy | Points to same memory |
| **Changes Affect Original?** | âŒ No               | âœ… Yes                 |
| **Example**                  | `let x = 5`        | `let obj = { a: 1 }`  |


:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::



ğŸ§© What is Type Coercion in JavaScript?

Type coercion means automatically converting one data type into another when an 
operation involves different types.

JavaScript is a loosely typed or dynamically typed language â€”
so it automatically converts types when needed (for example, number â†’ string).

âš™ï¸ Two Types of Coercion


| Type                  | Description                 | Example           |
| --------------------- | --------------------------- | ----------------- |
| **Implicit Coercion** | JS converts automatically   | `'5' + 2 â†’ '52'`  |
| **Explicit Coercion** | Developer converts manually | `Number('5') â†’ 5` |






ğŸ§  1ï¸âƒ£ Implicit Coercion (Automatic Conversion)

JavaScript performs conversions automatically based on context â€”
especially with operators like +, -, ==, and !.

ğŸ§© Example 1 â€” String + Number
console.log('5' + 2);


+ triggers string concatenation

'5' + 2 â†’ '52'

âœ… Output: '52' (string)

ğŸ§© Example 2 â€” Subtraction forces numeric conversion
console.log('5' - 2);


- works only on numbers, so '5' becomes 5.

5 - 2 = 3

âœ… Output: 3 (number)

ğŸ§© Example 3 â€” Boolean to Number
console.log(true + 1);  // true â†’ 1
console.log(false + 10); // false â†’ 0


âœ… Output:

2
10

ğŸ§© Example 4 â€” Logical NOT
console.log(!'');   // true, because '' is falsy
console.log(!'Hi'); // false, because 'Hi' is truthy

ğŸ§© Example 5 â€” Equality (==)
console.log('5' == 5);  // true â†’ '5' converted to number
console.log(0 == false); // true â†’ both become 0

ğŸ§  2ï¸âƒ£ Explicit Coercion (Manual Conversion)

You manually convert using functions or operators.


| Conversion         | Method           | Example                   | Result  |
| ------------------ | ---------------- | ------------------------- | ------- |
| String â†’ Number    | `Number()`       | `Number('123')`           | `123`   |
| Number â†’ String    | `String()`       | `String(123)`             | `'123'` |
| Boolean â†’ Number   | `Number(true)`   | `1`                       |         |
| Anything â†’ Boolean | `Boolean(value)` | `Boolean('hello') â†’ true` |         |
| Quick coercion     | Unary `+`        | `+'123' â†’ 123`            |         |




ğŸ§© Example
let x = '10';
let y = Number(x);   // explicit
let z = +x;          // shorthand

console.log(y, z);   // 10 10 (numbers)

âš–ï¸ 3ï¸âƒ£ Coercion Rules Summary

| Value       | To Boolean | To Number | To String           |
| ----------- | ---------- | --------- | ------------------- |
| `false`     | `false`    | `0`       | `'false'`           |
| `true`      | `true`     | `1`       | `'true'`            |
| `''`        | `false`    | `0`       | `''`                |
| `'123'`     | `true`     | `123`     | `'123'`             |
| `null`      | `false`    | `0`       | `'null'`            |
| `undefined` | `false`    | `NaN`     | `'undefined'`       |
| `[]`        | `true`     | `0`       | `''`                |
| `[1]`       | `true`     | `1`       | `'1'`               |
| `{}`        | `true`     | `NaN`     | `'[object Object]'` |




ğŸ§© 4ï¸âƒ£ Common Interview Examples
ğŸ”¸ [] + {}
[] + {} â†’ '' + '[object Object]' â†’ "[object Object]"

ğŸ”¸ {} + []
{} + [] â†’ {} interpreted as block â†’ +[] â†’ 0

ğŸ”¸ true == '1'

'1' becomes number 1

true becomes number 1
âœ… true
